#!/usr/bin/env python3
"""Collect misclassified cases into a single review directory.

Give the path to the misclassified.csv generated by test_sequence.py and a
destination folder. For every row marked "is_correct == 0", this script copies
(or hard-links) all listed frame images into the destination grouped by case_id.
"""
from __future__ import annotations

import argparse
import csv
import os
import shutil
from typing import Iterable


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Collect misclassified cases and their frames into a review folder.")
    parser.add_argument("csv_path", type=str, help="Path to misclassified.csv produced by test_sequence.py")
    parser.add_argument("output_dir", type=str, help="Folder to store copied frames grouped by case_id")
    parser.add_argument("--mode", choices=["copy", "link", "symlink"], default="copy",
                        help="How to materialize frames in the output folder")
    parser.add_argument("--overwrite", action="store_true", help="Remove existing output directory before collecting")
    return parser.parse_args()


def ensure_output_dir(path: str, overwrite: bool) -> None:
    if os.path.exists(path):
        if overwrite:
            shutil.rmtree(path)
        else:
            raise FileExistsError(f"Output directory '{path}' already exists. Use --overwrite to replace it.")
    os.makedirs(path, exist_ok=True)


def resolve_case_dir(base_dir: str, case_dir_field: str) -> str:
    if os.path.isabs(case_dir_field):
        return case_dir_field

    # 如果当前工作目录下能直接访问，优先使用该路径
    if case_dir_field and os.path.isdir(case_dir_field):
        return os.path.abspath(case_dir_field)

    candidate = os.path.normpath(os.path.join(base_dir, case_dir_field))
    return candidate


def collect_frames(src_dir: str, frame_files: Iterable[str], dst_dir: str, mode: str) -> None:
    os.makedirs(dst_dir, exist_ok=True)
    for name in frame_files:
        if not name:
            continue
        src_path = os.path.join(src_dir, name)
        if not os.path.isfile(src_path):
            print(f"[WARN] Missing source file: {src_path}")
            continue
        dst_path = os.path.join(dst_dir, name)
        if os.path.exists(dst_path):
            continue
        if mode == "copy":
            shutil.copy2(src_path, dst_path)
        elif mode == "link":
            try:
                os.link(src_path, dst_path)
            except (OSError, NotImplementedError):
                shutil.copy2(src_path, dst_path)
        elif mode == "symlink":
            os.symlink(src_path, dst_path)


def main() -> None:
    args = parse_args()

    csv_path = os.path.abspath(args.csv_path)
    if not os.path.isfile(csv_path):
        raise FileNotFoundError(csv_path)

    ensure_output_dir(args.output_dir, args.overwrite)
    results_root = os.path.dirname(csv_path)

    with open(csv_path, "r", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        rows = [row for row in reader if row.get("is_correct", "0") == "0"]

    for row in rows:
        case_id = row.get("case_id", "unknown_case")
        case_dir_field = row.get("case_dir", "")
        frame_list = [name.strip() for name in row.get("frame_files", "").split(";") if name.strip()]

        case_src_dir = resolve_case_dir(results_root, case_dir_field)
        if not os.path.isdir(case_src_dir):
            print(f"[WARN] Case directory missing: {case_src_dir}")
            continue

        dst_case_dir = os.path.join(args.output_dir, case_id)
        collect_frames(case_src_dir, frame_list, dst_case_dir, args.mode)
        print(f"[INFO] Collected {case_id} -> {dst_case_dir}")

    print(f"[INFO] Completed. Review folder: {args.output_dir}")


if __name__ == "__main__":
    main()
